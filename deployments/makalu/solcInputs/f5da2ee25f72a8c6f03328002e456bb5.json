{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/HelperManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./ValidatorHelper.sol\";\r\n\r\ncontract HelperManager is Ownable {\r\n    mapping(address => bool) admins;\r\n\r\n    mapping(address => address) helperAdmin;\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \"deny\");\r\n        _;\r\n    }\r\n\r\n    event CreateHelper(address indexed _helper, address _admin);\r\n\r\n    event EditHelperAdmin(address indexed _helper, address indexed _admin);\r\n\r\n    constructor() {}\r\n\r\n    function updateAdmin(address _user, bool flag) public onlyOwner {\r\n        admins[_user] = flag;\r\n    }\r\n\r\n    function editHelperAdmin(address _helper, address _newAdmin)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_newAdmin != address(0), \"helperAdmin not be zero address\");\r\n\r\n        require(helperAdmin[_helper] != address(0), \"helper not exiest\");\r\n\r\n        helperAdmin[_helper] = _newAdmin;\r\n\r\n        emit EditHelperAdmin(_helper, _newAdmin);\r\n    }\r\n\r\n    function createHelper(address _admin) public onlyAdmin {\r\n        require(_admin != address(0), \"helperAdmin not be zero address\");\r\n        ValidatorHelper helper = new ValidatorHelper();\r\n        require(address(helper) != address(0), \"create failed\");\r\n        helperAdmin[address(helper)] = _admin;\r\n\r\n        emit CreateHelper(address(helper), _admin);\r\n    }\r\n\r\n    function isAdmin(address _user) public view returns (bool) {\r\n        return admins[_user] || _user == owner();\r\n    }\r\n\r\n    function getHelperAdmin(address _helper) public view returns (address) {\r\n        return helperAdmin[_helper];\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IAccounts.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ninterface IAccounts {\r\n    function isAccount(address) external view returns (bool);\r\n\r\n    function voteSignerToAccount(address) external view returns (address);\r\n\r\n    function validatorSignerToAccount(address) external view returns (address);\r\n\r\n    function attestationSignerToAccount(address)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function signerToAccount(address) external view returns (address);\r\n\r\n    function getAttestationSigner(address) external view returns (address);\r\n\r\n    function getValidatorSigner(address) external view returns (address);\r\n\r\n    function getVoteSigner(address) external view returns (address);\r\n\r\n    function hasAuthorizedVoteSigner(address) external view returns (bool);\r\n\r\n    function hasAuthorizedValidatorSigner(address) external view returns (bool);\r\n\r\n    function hasAuthorizedAttestationSigner(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function setIndexedSigner(address signer, bytes32 role) external;\r\n\r\n    function setAccountDataEncryptionKey(bytes calldata) external;\r\n\r\n    function setMetadataURL(string calldata) external;\r\n\r\n    function setName(string calldata) external;\r\n\r\n    function setWalletAddress(\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32\r\n    ) external;\r\n\r\n    function setAccount(\r\n        string calldata,\r\n        bytes calldata,\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32\r\n    ) external;\r\n\r\n    function getDataEncryptionKey(address) external view returns (bytes memory);\r\n\r\n    function getWalletAddress(address) external view returns (address);\r\n\r\n    function getMetadataURL(address) external view returns (string memory);\r\n\r\n    function batchGetMetadataURL(address[] calldata)\r\n        external\r\n        view\r\n        returns (uint256[] memory, bytes memory);\r\n\r\n    function getName(address) external view returns (string memory);\r\n\r\n    function authorizeVoteSigner(\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32\r\n    ) external;\r\n\r\n    function authorizeValidatorSigner(\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32\r\n    ) external;\r\n\r\n    function authorizeValidatorSignerWithPublicKey(\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32,\r\n        bytes calldata\r\n    ) external;\r\n\r\n    function authorizeSignerWithSignature(\r\n        address signer,\r\n        bytes32 role,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function authorizeValidatorSignerWithKeys(\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32,\r\n        bytes calldata,\r\n        bytes calldata,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external;\r\n\r\n    function authorizeAttestationSigner(\r\n        address,\r\n        uint8,\r\n        bytes32,\r\n        bytes32\r\n    ) external;\r\n\r\n    function completeSignerAuthorization(address account, bytes32 role)\r\n        external;\r\n\r\n    function removeIndexedSigner(bytes32 role) external;\r\n\r\n    function removeSigner(address signer, bytes32 role) external;\r\n\r\n    function removeVoteSigner() external;\r\n\r\n    function removeValidatorSigner() external;\r\n\r\n     function removeAttestationSigner() external;\r\n\r\n    function authorizeSigner(address signer, bytes32 role) external;\r\n\r\n    function createAccount() external returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IElection.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ninterface IElection {\r\n    function activateForAccount(address validator, address account)\r\n        external\r\n        returns (bool);\r\n\r\n    function electValidatorSigners() external view returns (address[] memory);\r\n\r\n    function electNValidatorSigners(uint256, uint256)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    function vote(\r\n        address,\r\n        uint256,\r\n        address,\r\n        address\r\n    ) external returns (bool);\r\n\r\n    function activate(address) external returns (bool);\r\n\r\n    function revokeActive(\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function revokeAllActive(\r\n        address,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function revokePending(\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n\r\n    // view functions\r\n    function getElectableValidators() external view returns (uint256, uint256);\r\n\r\n    function getElectabilityThreshold() external view returns (uint256);\r\n\r\n    function getNumVotesReceivable() external view returns (uint256);\r\n\r\n    function getTotalVotes() external view returns (uint256);\r\n\r\n    function getActiveVotes() external view returns (uint256);\r\n\r\n    function getTotalVotesByAccount(address) external view returns (uint256);\r\n\r\n    function getPendingVotesForValidatorByAccount(address, address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getActiveVotesForValidatorByAccount(address, address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTotalVotesForValidatorByAccount(address, address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    //  function getActiveVoteForValidatorByAccount(address, address) external view returns (uint256);\r\n    function getTotalVotesForValidator(address) external view returns (uint256);\r\n\r\n    function getActiveVotesForValidator(address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPendingVotesForValidator(address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getValidatorEligibility(address) external view returns (bool);\r\n\r\n    function getTopValidators(uint256) external view returns (address[] memory);\r\n\r\n    function getValidatorsVotedForByAccount(address)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    function getEligibleValidators() external view returns (address[] memory);\r\n\r\n    function getTotalVotesForEligibleValidators()\r\n        external\r\n        view\r\n        returns (address[] memory, uint256[] memory);\r\n\r\n    function getCurrentValidatorSigners()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    function canReceiveVotes(address, uint256) external view returns (bool);\r\n\r\n    function hasActivatablePendingVotes(address, address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n}\r\n"
    },
    "contracts/interfaces/ILockedGold.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ninterface ILockedGold {\r\n    function getAccountNonvotingLockedGold(address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getAccountTotalLockedGold(address) external view returns (uint256);\r\n\r\n    function getTotalLockedGold() external view returns (uint256);\r\n\r\n    function getPendingWithdrawals(address)\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory);\r\n\r\n    function getTotalPendingWithdrawals(address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function lock() external payable;\r\n\r\n    function unlock(uint256) external;\r\n\r\n    function relock(uint256, uint256) external;\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/interfaces/IValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n//pragma experimental ABIEncoderV2;\r\n\r\ninterface IValidators {\r\n    function registerValidator(uint256 commission, address lesser, address greater,bytes[] calldata blsBlsG1BlsPopEcdsaPub)\r\n    external\r\n    returns (bool);\r\n\r\n    function revertRegisterValidator() external returns(bool);\r\n\r\n    function deregisterValidator() external returns (bool);\r\n\r\n    function updateBlsPublicKey(bytes calldata,bytes calldata, bytes calldata) external returns (bool);\r\n\r\n    function updateCommission() external;\r\n\r\n    function setNextCommissionUpdate(uint256) external;\r\n\r\n    // view functions\r\n\r\n    function isPendingDeRegisterValidator() external view returns (bool);\r\n\r\n    function getAccountLockedGoldRequirement(address) external view returns (uint256);\r\n\r\n    function meetsAccountLockedGoldRequirements(address) external view returns (bool);\r\n\r\n    function updatePublicKeys(address, address, bytes calldata,bytes calldata, bytes calldata, bytes calldata)\r\n    external\r\n    returns (bool);\r\n\r\n    function getValidatorLockedGoldRequirements() external view returns (uint256, uint256);\r\n\r\n    function isValidator(address) external view returns (bool);\r\n\r\n\r\n\r\n}\r\n"
    },
    "contracts/ValidatorHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./interfaces/IAccounts.sol\";\nimport \"./interfaces/IValidators.sol\";\nimport \"./interfaces/ILockedGold.sol\";\nimport \"./interfaces/IElection.sol\";\nimport \"./HelperManager.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract ValidatorHelper is ReentrancyGuard {\n    address public constant ACCOUNTS_ADDRESS =\n        0x000000000000000000000000000000000000d010;\n    address public constant LOCKED_GOLDADDRESS =\n        0x000000000000000000000000000000000000d011;\n    address public constant VALIDATORS_ADDRESS =\n        0x000000000000000000000000000000000000D012;\n    address public constant ELECTIONS_ADDRESS =\n        0x000000000000000000000000000000000000d013;\n\n    uint256 public constant validatorMinLockRequire = 1000000 ether;\n\n    uint256 public sponsorAmount;\n\n    HelperManager public manager;\n\n    constructor() {\n        manager = HelperManager(msg.sender);\n    }\n\n    modifier onlyManageAdmin() {\n        require(manager.isAdmin(msg.sender), \"manager :: deny\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(\n            manager.getHelperAdmin(address(this)) == msg.sender ||\n                manager.isAdmin(msg.sender),\n            \"deny\"\n        );\n        _;\n    }\n\n    receive() external payable {}\n\n    // <-------------------------------------- validator ----------------------------------------------->\n\n    function registerValidator(\n        uint256 commission, //100000\n        address lesser,\n        address greater,\n        bytes[] calldata keys\n    ) public onlyAdmin returns (bool) {\n        IValidators validator = IValidators(VALIDATORS_ADDRESS);\n        bool success = validator.registerValidator(\n            commission,\n            lesser,\n            greater,\n            keys\n        );\n        require(success, \"Failed to register validator\");\n        return true;\n    }\n\n    function setNextCommissionUpdate(uint256 commission) external onlyAdmin {\n        IValidators(VALIDATORS_ADDRESS).setNextCommissionUpdate(commission);\n    }\n\n    function updateCommission() external onlyAdmin {\n        IValidators(VALIDATORS_ADDRESS).updateCommission();\n    }\n\n    function updateBlsPublicKey(\n        bytes calldata blsPublicKey,\n        bytes calldata blsG1PublicKey,\n        bytes calldata blsPop\n    ) external onlyAdmin returns (bool) {\n        return\n            IValidators(VALIDATORS_ADDRESS).updateBlsPublicKey(\n                blsPublicKey,\n                blsG1PublicKey,\n                blsPop\n            );\n    }\n\n    function deregisterValidator() external onlyAdmin returns (bool) {\n        return IValidators(VALIDATORS_ADDRESS).deregisterValidator();\n    }\n\n    function revertRegisterValidator() external onlyAdmin returns (bool) {\n        return IValidators(VALIDATORS_ADDRESS).revertRegisterValidator();\n    }\n\n    function getActiveVotesForValidatorByAccount(\n        address validator,\n        address account\n    ) public view returns (uint256) {\n        IElection election = IElection(VALIDATORS_ADDRESS);\n        return election.getActiveVotesForValidatorByAccount(validator, account);\n    }\n\n    function isPendingDeRegisterValidator() external view returns (bool) {\n        return IValidators(VALIDATORS_ADDRESS).isPendingDeRegisterValidator();\n    }\n\n    // <-------------------------------------- Election ----------------------------------------------->\n\n    function voter(\n        address validator,\n        uint256 value,\n        address lesser,\n        address greater\n    ) public onlyAdmin returns (bool) {\n        IElection election = IElection(ELECTIONS_ADDRESS);\n        require(\n            election.vote(validator, value, lesser, greater),\n            \"Failed to voter\"\n        );\n        return true;\n    }\n\n    function activate(address validator) external onlyAdmin returns (bool) {\n        return IElection(ELECTIONS_ADDRESS).activate(validator);\n    }\n\n    function activateForAccount(address validator, address account)\n        external\n        onlyAdmin\n        returns (bool)\n    {\n        return\n            IElection(ELECTIONS_ADDRESS).activateForAccount(validator, account);\n    }\n\n    function revokePending(\n        address validator,\n        uint256 value,\n        address lesser,\n        address greater,\n        uint256 index\n    ) external onlyAdmin returns (bool) {\n        IElection election = IElection(ELECTIONS_ADDRESS);\n        require(\n            election.revokeActive(validator, value, lesser, greater, index),\n            \"Failed to revoke Pending\"\n        );\n        return true;\n    }\n\n    function revokeActive(\n        address validator,\n        uint256 value,\n        address lesser,\n        address greater,\n        uint256 index\n    ) public onlyAdmin returns (bool) {\n        IElection election = IElection(ELECTIONS_ADDRESS);\n        require(\n            election.revokeActive(validator, value, lesser, greater, index),\n            \"Failed to revoke active\"\n        );\n        return true;\n    }\n\n    function revokeAllActive(\n        address validator,\n        address lesser,\n        address greater,\n        uint256 index\n    ) external onlyAdmin returns (bool) {\n        return\n            IElection(ELECTIONS_ADDRESS).revokeAllActive(\n                validator,\n                lesser,\n                greater,\n                index\n            );\n    }\n\n    // <-------------------------------------- Accounts ----------------------------------------------->\n\n    function setAccount(\n        string calldata name,\n        bytes calldata dataEncryptionKey,\n        address walletAddress,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).setAccount(\n            name,\n            dataEncryptionKey,\n            walletAddress,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createAccount(string calldata name)\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        IAccounts account = IAccounts(ACCOUNTS_ADDRESS);\n        require(account.createAccount(), \"Failed to create account\");\n        account.setName(name);\n        return true;\n    }\n\n    function setName(string memory name) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).setName(name);\n    }\n\n    function setWalletAddress(\n        address walletAddress,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).setWalletAddress(walletAddress, v, r, s);\n    }\n\n    function setAccountDataEncryptionKey(bytes memory dataEncryptionKey)\n        public\n        onlyAdmin\n    {\n        IAccounts(ACCOUNTS_ADDRESS).setAccountDataEncryptionKey(\n            dataEncryptionKey\n        );\n    }\n\n    function setMetadataURL(string calldata metadataURL) external onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).setMetadataURL(metadataURL);\n    }\n\n    function setIndexedSigner(address signer, bytes32 role) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).setIndexedSigner(signer, role);\n    }\n\n    function authorizeSignerWithSignature(\n        address signer,\n        bytes32 role,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeSignerWithSignature(\n            signer,\n            role,\n            v,\n            r,\n            s\n        );\n    }\n\n    function authorizeVoteSigner(\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeVoteSigner(signer, v, r, s);\n    }\n\n    function authorizeValidatorSigner(\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeValidatorSigner(signer, v, r, s);\n    }\n\n    function authorizeValidatorSignerWithPublicKey(\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes calldata ecdsaPublicKey\n    ) external onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeValidatorSignerWithPublicKey(\n            signer,\n            v,\n            r,\n            s,\n            ecdsaPublicKey\n        );\n    }\n\n    function authorizeValidatorSignerWithKeys(\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes calldata ecdsaPublicKey,\n        bytes calldata blsPublicKey,\n        bytes calldata blsG1PublicKey,\n        bytes calldata blsPop\n    ) external onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeValidatorSignerWithKeys(\n            signer,\n            v,\n            r,\n            s,\n            ecdsaPublicKey,\n            blsPublicKey,\n            blsG1PublicKey,\n            blsPop\n        );\n    }\n\n    function authorizeAttestationSigner(\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeAttestationSigner(signer, v, r, s);\n    }\n\n    function authorizeSigner(address signer, bytes32 role) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).authorizeSigner(signer, role);\n    }\n\n    function completeSignerAuthorization(address account, bytes32 role)\n        public\n        onlyAdmin\n    {\n        IAccounts(ACCOUNTS_ADDRESS).completeSignerAuthorization(account, role);\n    }\n\n    function removeIndexedSigner(bytes32 role) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).removeIndexedSigner(role);\n    }\n\n    function removeSigner(address signer, bytes32 role) public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).removeSigner(signer, role);\n    }\n\n    function removeVoteSigner() public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).removeVoteSigner();\n    }\n\n    function removeValidatorSigner() public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).removeValidatorSigner();\n    }\n\n    function removeAttestationSigner() public onlyAdmin {\n        IAccounts(ACCOUNTS_ADDRESS).removeAttestationSigner();\n    }\n\n    // function authorize(\n    //     address signer,\n    //     uint8 v,\n    //     bytes32 r,\n    //     bytes32 s\n    // ) public onlyAdmin returns (bool) {\n    //     IAccounts account = IAccounts(accountsAddress);\n    //     account.authorizeValidatorSigner(signer, v, r, s);\n    //     return true;\n    // }\n\n    // <-------------------------------------- LockedGold ----------------------------------------------->\n\n    function lock(uint256 amount) public onlyAdmin returns (bool) {\n        (bool success, ) = LOCKED_GOLDADDRESS.call{value: amount}(\n            abi.encodeWithSignature(\"lock()\", \"\")\n        );\n        require(success, \"Failed to lock gold\");\n        return true;\n    }\n\n    function unlock(uint256 value) external onlyAdmin {\n        //  if (IValidators(validatorsAddress).isValidator(address(this))) {\n        ILockedGold(LOCKED_GOLDADDRESS).unlock(value);\n    }\n\n    function relock(uint256 index, uint256 value) external onlyAdmin {\n        ILockedGold(LOCKED_GOLDADDRESS).relock(index, value);\n    }\n\n    function withdraw(uint256 index) public onlyAdmin returns (bool) {\n        ILockedGold locked = ILockedGold(LOCKED_GOLDADDRESS);\n        locked.withdraw(index);\n        return true;\n    }\n\n    function getAccountTotalLockedGold(address account)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            ILockedGold(LOCKED_GOLDADDRESS).getAccountTotalLockedGold(account);\n    }\n\n    function getAccountNonvotingLockedGold(address account)\n        public\n        view\n        returns (uint256)\n    {\n        ILockedGold locked = ILockedGold(LOCKED_GOLDADDRESS);\n        return locked.getAccountNonvotingLockedGold(account);\n    }\n\n    function getPendingWithdrawals(address account)\n        public\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return ILockedGold(LOCKED_GOLDADDRESS).getPendingWithdrawals(account);\n    }\n\n    function getTotalPendingWithdrawals(address account)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            ILockedGold(LOCKED_GOLDADDRESS).getTotalPendingWithdrawals(account);\n    }\n\n    // <-------------------------------------- other ----------------------------------------------->\n    function withrawOut(\n        uint256 value,\n        address payable reveiver,\n        bool isSponsor\n    ) public nonReentrant returns (bool) {\n        uint256 amount;\n\n        if (isSponsor) {\n            require(manager.isAdmin(msg.sender), \"deny\");\n            require(\n                getBalance() >= sponsorAmount && sponsorAmount > 0,\n                \"balance unenoungh\"\n            );\n\n            amount = sponsorAmount;\n\n            sponsorAmount = 0;\n        } else {\n            require(\n                manager.getHelperAdmin(address(this)) == msg.sender,\n                \"deny\"\n            );\n            require(getBalance() >= value, \"balance unenoungh\");\n\n            require(\n                getBalance() + getAccountTotalLockedGold(address((this))) >=\n                    value + sponsorAmount,\n                \"too many\"\n            );\n\n            amount = value;\n        }\n\n        reveiver.transfer(amount);\n\n        return true;\n    }\n\n    function sponsor() public payable onlyManageAdmin {\n        sponsorAmount += msg.value;\n    }\n\n    function emergencyExit(address payable _reveiver) public onlyManageAdmin {\n        _reveiver.transfer(getBalance());\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}